import { __decorate, __metadata, __read, __spread } from "tslib";
import { ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, Input, OnChanges, OnInit, Output, QueryList, SimpleChanges } from '@angular/core';
import { combineLatest } from 'rxjs';
import { ScriptLoaderService } from '../../script-loader/script-loader.service';
import { ControlWrapperComponent } from '../control-wrapper/control-wrapper.component';
import * as ɵngcc0 from '@angular/core';

var _c0 = ["*"];
var DashboardComponent = /** @class */ (function () {
    function DashboardComponent(element, loaderService) {
        this.element = element;
        this.loaderService = loaderService;
        /**
         * The dashboard has completed drawing and is ready to accept changes.
         *
         * The ready event will also fire:
         * - after the completion of a dashboard refresh triggered by a user or programmatic interaction with one of the controls,
         * - after redrawing any chart on the dashboard.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when an error occurs when attempting to render the dashboard.
         * One or more of the controls and charts that are part of the dashboard may have failed rendering.
         */
        this.error = new EventEmitter();
        this.initialized = false;
    }
    DashboardComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.loaderService.loadChartPackages('controls').subscribe(function () {
            _this.createDataTable();
            _this.createDashboard();
            _this.initialized = true;
        });
    };
    DashboardComponent.prototype.ngOnChanges = function (changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.data || changes.columns) {
            this.createDataTable();
            this.dashboard.draw(this.dataTable);
        }
    };
    DashboardComponent.prototype.createDashboard = function () {
        var _this = this;
        // TODO: This should happen in the control wrapper
        // However, I don't yet know how to do this because then `bind()` would get called multiple times
        // for the same control if something changes. This is not supported by google charts as far as I can tell
        // from their source code.
        var controlWrappersReady$ = this.controlWrappers.map(function (control) { return control.wrapperReady$; });
        var chartsReady$ = this.controlWrappers
            .map(function (control) { return control.for; })
            .map(function (charts) {
            if (Array.isArray(charts)) {
                // CombineLatest waits for all observables
                return combineLatest(charts.map(function (chart) { return chart.wrapperReady$; }));
            }
            else {
                return charts.wrapperReady$;
            }
        });
        // We have to wait for all chart wrappers and control wrappers to be initialized
        // before we can compose them together to create the dashboard
        combineLatest(__spread(controlWrappersReady$, chartsReady$)).subscribe(function () {
            _this.dashboard = new google.visualization.Dashboard(_this.element.nativeElement);
            _this.initializeBindings();
            _this.dashboard.draw(_this.dataTable);
        });
    };
    DashboardComponent.prototype.initializeBindings = function () {
        var _this = this;
        this.controlWrappers.forEach(function (control) {
            if (Array.isArray(control.for)) {
                var chartWrappers = control.for.map(function (chart) { return chart.chartWrapper; });
                _this.dashboard.bind(control.controlWrapper, chartWrappers);
            }
            else {
                _this.dashboard.bind(control.controlWrapper, control.for.chartWrapper);
            }
        });
    };
    DashboardComponent.prototype.createDataTable = function () {
        if (this.data == null) {
            return;
        }
        var firstRowIsData = true;
        if (this.columns != null) {
            firstRowIsData = false;
        }
        this.dataTable = google.visualization.arrayToDataTable(this.getDataAsTable(), firstRowIsData);
    };
    DashboardComponent.prototype.getDataAsTable = function () {
        if (this.columns) {
            return __spread([this.columns], this.data);
        }
        else {
            return this.data;
        }
    };
    DashboardComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ScriptLoaderService }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], DashboardComponent.prototype, "data", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], DashboardComponent.prototype, "columns", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], DashboardComponent.prototype, "ready", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], DashboardComponent.prototype, "error", void 0);
    __decorate([
        ContentChildren(ControlWrapperComponent),
        __metadata("design:type", QueryList)
    ], DashboardComponent.prototype, "controlWrappers", void 0);
    DashboardComponent = __decorate([ __metadata("design:paramtypes", [ElementRef, ScriptLoaderService])
    ], DashboardComponent);
DashboardComponent.ɵfac = function DashboardComponent_Factory(t) { return new (t || DashboardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ScriptLoaderService)); };
DashboardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DashboardComponent, selectors: [["dashboard"]], contentQueries: function DashboardComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ControlWrapperComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.controlWrappers = _t);
    } }, hostAttrs: [1, "dashboard"], inputs: { data: "data", columns: "columns" }, outputs: { ready: "ready", error: "error" }, exportAs: ["dashboard"], features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function DashboardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DashboardComponent, [{
        type: Component,
        args: [{
                selector: 'dashboard',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'dashboard',
                host: { class: 'dashboard' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ScriptLoaderService }]; }, { ready: [{
            type: Output
        }], error: [{
            type: Output
        }], data: [{
            type: Input
        }], columns: [{
            type: Input
        }], controlWrappers: [{
            type: ContentChildren,
            args: [ControlWrapperComponent]
        }] }); })();
    return DashboardComponent;
}());
export { DashboardComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFzaGJvYXJkLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsibmc6L2FuZ3VsYXItZ29vZ2xlLWNoYXJ0cy9saWIvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsZUFBZSxFQUNmLFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUNMLFNBQVMsRUFDVCxNQUFNLEVBQ04sTUFBTSxFQUNOLFNBQVMsRUFDVCxhQUFhLEVBQ2QsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUdyQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUVoRixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw4Q0FBOEMsQ0FBQzs7OztBQVN2RjtBQUFzRCxJQTBDcEQsNEJBQW9CLE9BQW1CLEVBQVUsYUFBa0M7QUFBSSxRQUFuRSxZQUFPLEdBQVAsT0FBTyxDQUFZO0FBQUMsUUFBUyxrQkFBYSxHQUFiLGFBQWEsQ0FBcUI7QUFBQyxRQXhCcEY7QUFDRjtBQUVDO0FBQVc7QUFDTTtBQUNNO0FBR1osV0FGUDtBQUNMLFFBQ1MsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7QUFDMUMsUUFDRTtBQUNGO0FBQ007QUFFQSxXQUREO0FBQ0wsUUFDUyxVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQW1CLENBQUM7QUFDckQsUUFNVSxnQkFBVyxHQUFHLEtBQUssQ0FBQztBQUM5QixJQUN3RixDQUFDO0FBQ3pGLElBQ1MscUNBQVEsR0FBZjtBQUFjLFFBQWQsaUJBTUM7QUFDSCxRQU5JLElBQUksQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxDQUFDO0FBQ3pELFlBQUEsS0FBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0FBQzdCLFlBQU0s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a0NBQTBCLFNBQVM7QUFBRSwrREFBd0I7QUFFOUQsSUF0Q2Esa0JBQWtCLHdCQVA5QixTQUFTLENBQUMsY0FDVCxRQUFRLEVBQUUsV0FBVyx0REFNZixrQ0EwQ3VCLFVBQVUsRUFBeUIsbUJBQW1CO0FBL0NuRixRQUFRLEVBQUUsVkErQzRFLE9BMUMzRSxrQkFBa0IsQ0F3SDlCO1NBN0hzQyxjQUNyQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTSxjQUMvQyxRQUFRLEVBQUUsV0FBVyxjQUNyQixJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFVBQzdCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkEwSEY7QUFBQyxJQURELHlCQUFDO0FBQ0EsQ0FEQSxBQXhIRCxJQXdIQztBQUNELFNBekhhLGtCQUFrQjtBQUFJIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENoYXJ0RXJyb3JFdmVudCB9IGZyb20gJy4uLy4uL21vZGVscy9ldmVudHMubW9kZWwnO1xuaW1wb3J0IHsgU2NyaXB0TG9hZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NjcmlwdC1sb2FkZXIvc2NyaXB0LWxvYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IENvbHVtbiwgUm93IH0gZnJvbSAnLi4vY2hhcnQtYmFzZS9jaGFydC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb250cm9sV3JhcHBlckNvbXBvbmVudCB9IGZyb20gJy4uL2NvbnRyb2wtd3JhcHBlci9jb250cm9sLXdyYXBwZXIuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZGFzaGJvYXJkJyxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGV4cG9ydEFzOiAnZGFzaGJvYXJkJyxcbiAgaG9zdDogeyBjbGFzczogJ2Rhc2hib2FyZCcgfVxufSlcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIC8qKlxuICAgKiBEYXRhIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgdGFibGUuXG4gICAqXG4gICAqIFRoaXMgbXVzdCBhbHNvIGNvbnRhaW4gYWxsIHJvbGVzIHRoYXQgYXJlIHNldCBpbiB0aGUgYGNvbHVtbnNgIHByb3BlcnR5LlxuICAgKi9cbiAgQElucHV0KClcbiAgcHVibGljIGRhdGEhOiBSb3dbXTtcblxuICAvKipcbiAgICogVGhlIGNvbHVtbnMgdGhlIGBkYXRhYCBjb25zaXN0cyBvZi5cbiAgICogVGhlIGxlbmd0aCBvZiB0aGlzIGFycmF5IG11c3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiBlYWNoIHJvdyBpbiB0aGUgYGRhdGFgIG9iamVjdC5cbiAgICpcbiAgICogSWYge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2NoYXJ0L2ludGVyYWN0aXZlL2RvY3Mvcm9sZXMgcm9sZXN9IHNob3VsZCBiZSBhcHBsaWVkLCB0aGV5IG11c3QgYmUgaW5jbHVkZWQgaW4gdGhpcyBhcnJheSBhcyB3ZWxsLlxuICAgKi9cbiAgQElucHV0KClcbiAgcHVibGljIGNvbHVtbnM6IENvbHVtbltdO1xuXG4gIC8qKlxuICAgKiBUaGUgZGFzaGJvYXJkIGhhcyBjb21wbGV0ZWQgZHJhd2luZyBhbmQgaXMgcmVhZHkgdG8gYWNjZXB0IGNoYW5nZXMuXG4gICAqXG4gICAqIFRoZSByZWFkeSBldmVudCB3aWxsIGFsc28gZmlyZTpcbiAgICogLSBhZnRlciB0aGUgY29tcGxldGlvbiBvZiBhIGRhc2hib2FyZCByZWZyZXNoIHRyaWdnZXJlZCBieSBhIHVzZXIgb3IgcHJvZ3JhbW1hdGljIGludGVyYWN0aW9uIHdpdGggb25lIG9mIHRoZSBjb250cm9scyxcbiAgICogLSBhZnRlciByZWRyYXdpbmcgYW55IGNoYXJ0IG9uIHRoZSBkYXNoYm9hcmQuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgcHVibGljIHJlYWR5ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIGFuIGVycm9yIG9jY3VycyB3aGVuIGF0dGVtcHRpbmcgdG8gcmVuZGVyIHRoZSBkYXNoYm9hcmQuXG4gICAqIE9uZSBvciBtb3JlIG9mIHRoZSBjb250cm9scyBhbmQgY2hhcnRzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIGRhc2hib2FyZCBtYXkgaGF2ZSBmYWlsZWQgcmVuZGVyaW5nLlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIHB1YmxpYyBlcnJvciA9IG5ldyBFdmVudEVtaXR0ZXI8Q2hhcnRFcnJvckV2ZW50PigpO1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oQ29udHJvbFdyYXBwZXJDb21wb25lbnQpXG4gIHByaXZhdGUgY29udHJvbFdyYXBwZXJzOiBRdWVyeUxpc3Q8Q29udHJvbFdyYXBwZXJDb21wb25lbnQ+O1xuXG4gIHByaXZhdGUgZGFzaGJvYXJkOiBnb29nbGUudmlzdWFsaXphdGlvbi5EYXNoYm9hcmQ7XG4gIHByaXZhdGUgZGF0YVRhYmxlOiBnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVGFibGU7XG4gIHByaXZhdGUgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHByaXZhdGUgbG9hZGVyU2VydmljZTogU2NyaXB0TG9hZGVyU2VydmljZSkge31cblxuICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5sb2FkZXJTZXJ2aWNlLmxvYWRDaGFydFBhY2thZ2VzKCdjb250cm9scycpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmNyZWF0ZURhdGFUYWJsZSgpO1xuICAgICAgdGhpcy5jcmVhdGVEYXNoYm9hcmQoKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlcy5kYXRhIHx8IGNoYW5nZXMuY29sdW1ucykge1xuICAgICAgdGhpcy5jcmVhdGVEYXRhVGFibGUoKTtcbiAgICAgIHRoaXMuZGFzaGJvYXJkLmRyYXcodGhpcy5kYXRhVGFibGUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRGFzaGJvYXJkKCkge1xuICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGhhcHBlbiBpbiB0aGUgY29udHJvbCB3cmFwcGVyXG4gICAgLy8gSG93ZXZlciwgSSBkb24ndCB5ZXQga25vdyBob3cgdG8gZG8gdGhpcyBiZWNhdXNlIHRoZW4gYGJpbmQoKWAgd291bGQgZ2V0IGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgIC8vIGZvciB0aGUgc2FtZSBjb250cm9sIGlmIHNvbWV0aGluZyBjaGFuZ2VzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgZ29vZ2xlIGNoYXJ0cyBhcyBmYXIgYXMgSSBjYW4gdGVsbFxuICAgIC8vIGZyb20gdGhlaXIgc291cmNlIGNvZGUuXG4gICAgY29uc3QgY29udHJvbFdyYXBwZXJzUmVhZHkkID0gdGhpcy5jb250cm9sV3JhcHBlcnMubWFwKGNvbnRyb2wgPT4gY29udHJvbC53cmFwcGVyUmVhZHkkKTtcbiAgICBjb25zdCBjaGFydHNSZWFkeSQgPSB0aGlzLmNvbnRyb2xXcmFwcGVyc1xuICAgICAgLm1hcChjb250cm9sID0+IGNvbnRyb2wuZm9yKVxuICAgICAgLm1hcChjaGFydHMgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGFydHMpKSB7XG4gICAgICAgICAgLy8gQ29tYmluZUxhdGVzdCB3YWl0cyBmb3IgYWxsIG9ic2VydmFibGVzXG4gICAgICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoY2hhcnRzLm1hcChjaGFydCA9PiBjaGFydC53cmFwcGVyUmVhZHkkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXJ0cy53cmFwcGVyUmVhZHkkO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIC8vIFdlIGhhdmUgdG8gd2FpdCBmb3IgYWxsIGNoYXJ0IHdyYXBwZXJzIGFuZCBjb250cm9sIHdyYXBwZXJzIHRvIGJlIGluaXRpYWxpemVkXG4gICAgLy8gYmVmb3JlIHdlIGNhbiBjb21wb3NlIHRoZW0gdG9nZXRoZXIgdG8gY3JlYXRlIHRoZSBkYXNoYm9hcmRcbiAgICBjb21iaW5lTGF0ZXN0KFsuLi5jb250cm9sV3JhcHBlcnNSZWFkeSQsIC4uLmNoYXJ0c1JlYWR5JF0pLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmRhc2hib2FyZCA9IG5ldyBnb29nbGUudmlzdWFsaXphdGlvbi5EYXNoYm9hcmQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgdGhpcy5pbml0aWFsaXplQmluZGluZ3MoKTtcbiAgICAgIHRoaXMuZGFzaGJvYXJkLmRyYXcodGhpcy5kYXRhVGFibGUpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplQmluZGluZ3MoKSB7XG4gICAgdGhpcy5jb250cm9sV3JhcHBlcnMuZm9yRWFjaChjb250cm9sID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRyb2wuZm9yKSkge1xuICAgICAgICBjb25zdCBjaGFydFdyYXBwZXJzID0gY29udHJvbC5mb3IubWFwKGNoYXJ0ID0+IGNoYXJ0LmNoYXJ0V3JhcHBlcik7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkLmJpbmQoY29udHJvbC5jb250cm9sV3JhcHBlciwgY2hhcnRXcmFwcGVycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhc2hib2FyZC5iaW5kKGNvbnRyb2wuY29udHJvbFdyYXBwZXIsIGNvbnRyb2wuZm9yLmNoYXJ0V3JhcHBlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURhdGFUYWJsZSgpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZmlyc3RSb3dJc0RhdGEgPSB0cnVlO1xuICAgIGlmICh0aGlzLmNvbHVtbnMgIT0gbnVsbCkge1xuICAgICAgZmlyc3RSb3dJc0RhdGEgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGFUYWJsZSA9IGdvb2dsZS52aXN1YWxpemF0aW9uLmFycmF5VG9EYXRhVGFibGUodGhpcy5nZXREYXRhQXNUYWJsZSgpLCBmaXJzdFJvd0lzRGF0YSk7XG4gIH1cblxuICBwcml2YXRlIGdldERhdGFBc1RhYmxlKCk6IChSb3cgfCBDb2x1bW5bXSlbXSB7XG4gICAgaWYgKHRoaXMuY29sdW1ucykge1xuICAgICAgcmV0dXJuIFt0aGlzLmNvbHVtbnMsIC4uLnRoaXMuZGF0YV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgfVxuICB9XG59XG4iXX0=