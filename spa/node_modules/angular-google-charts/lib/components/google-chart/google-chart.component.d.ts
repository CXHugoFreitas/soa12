/// <reference types="@types/google.visualization" />
import { ElementRef, EventEmitter, OnChanges, OnInit, SimpleChanges } from '@angular/core';
import { ChartType } from '../../models/chart-type.model';
import { ChartErrorEvent, ChartMouseLeaveEvent, ChartMouseOverEvent, ChartReadyEvent, ChartSelectionChangedEvent } from '../../models/events.model';
import { ScriptLoaderService } from '../../script-loader/script-loader.service';
import { ChartBase, Column, Row } from '../chart-base/chart-base.component';
import { DashboardComponent } from '../dashboard/dashboard.component';
import * as ɵngcc0 from '@angular/core';
export interface Formatter {
    formatter: google.visualization.DefaultFormatter;
    colIndex: number;
}
export declare class GoogleChartComponent implements ChartBase, OnChanges, OnInit {
    private element;
    private scriptLoaderService;
    private dashboard?;
    /**
     * The type of the chart to create.
     */
    type: ChartType;
    /**
     * Data used to initialize the table.
     *
     * This must also contain all roles that are set in the `columns` property.
     */
    data: Row[];
    /**
     * The columns the `data` consists of.
     * The length of this array must match the length of each row in the `data` object.
     *
     * If {@link https://developers.google.com/chart/interactive/docs/roles roles} should be applied, they must be included in this array as well.
     */
    columns: Column[];
    /**
     * A convenience property used to set the title of the chart.
     *
     * This can also be set using `options.title`, which, if existant, will overwrite this value.
     */
    title?: string;
    /**
     * A convenience property used to set the width of the chart in pixels.
     *
     * This can also be set using `options.width`, which, if existant, will overwrite this value.
     */
    width?: number;
    /**
     * A convenience property used to set the height of the chart in pixels.
     *
     * This can also be set using `options.height`, which, if existant, will overwrite this value.
     */
    height?: number;
    /**
     * The chart-specific options. All options listen in the Google Charts documentation applying
     * to the chart type specified can be used here.
     */
    options: object;
    /**
     * Used to change the displayed value of the specified column in all rows.
     *
     * Each array element must consist of an instance of a [`formatter`](https://developers.google.com/chart/interactive/docs/reference#formatters)
     * and the index of the column you want the formatter to get applied to.
     */
    formatters?: Formatter[];
    /**
     * If this is set to `true`, the chart will be redrawn if the browser window is resized.
     * Defaults to `false` and should only be used when specifying the width or height of the chart
     * in percent.
     *
     * Note that this can impact performance.
     */
    dynamicResize: boolean;
    ready: EventEmitter<ChartReadyEvent<google.visualization.ChartBase>>;
    error: EventEmitter<ChartErrorEvent>;
    select: EventEmitter<ChartSelectionChangedEvent>;
    mouseover: EventEmitter<ChartMouseOverEvent>;
    mouseleave: EventEmitter<ChartMouseLeaveEvent>;
    private dataTable;
    private resizeSubscription;
    private wrapper;
    private wrapperReadySubject;
    private initialized;
    constructor(element: ElementRef, scriptLoaderService: ScriptLoaderService, dashboard?: DashboardComponent);
    readonly chart: google.visualization.ChartBase | null;
    readonly wrapperReady$: import("rxjs").Observable<google.visualization.ChartWrapper>;
    chartWrapper: google.visualization.ChartWrapper;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    private createDataTable;
    private getDataAsTable;
    private updateResizeListener;
    private mergeOptions;
    private applyFormatters;
    private registerChartEvents;
    private drawChart;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<GoogleChartComponent, [null, null, { optional: true; }]>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<GoogleChartComponent, "google-chart", ["googleChart"], { "options": "options"; "dynamicResize": "dynamicResize"; "type": "type"; "data": "data"; "columns": "columns"; "title": "title"; "width": "width"; "height": "height"; "formatters": "formatters"; }, { "ready": "ready"; "error": "error"; "select": "select"; "mouseover": "mouseover"; "mouseleave": "mouseleave"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ29vZ2xlLWNoYXJ0LmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJnb29nbGUtY2hhcnQuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkB0eXBlcy9nb29nbGUudmlzdWFsaXphdGlvblwiIC8+XG5pbXBvcnQgeyBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgT25Jbml0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDaGFydFR5cGUgfSBmcm9tICcuLi8uLi9tb2RlbHMvY2hhcnQtdHlwZS5tb2RlbCc7XG5pbXBvcnQgeyBDaGFydEVycm9yRXZlbnQsIENoYXJ0TW91c2VMZWF2ZUV2ZW50LCBDaGFydE1vdXNlT3ZlckV2ZW50LCBDaGFydFJlYWR5RXZlbnQsIENoYXJ0U2VsZWN0aW9uQ2hhbmdlZEV2ZW50IH0gZnJvbSAnLi4vLi4vbW9kZWxzL2V2ZW50cy5tb2RlbCc7XG5pbXBvcnQgeyBTY3JpcHRMb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2NyaXB0LWxvYWRlci9zY3JpcHQtbG9hZGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2hhcnRCYXNlLCBDb2x1bW4sIFJvdyB9IGZyb20gJy4uL2NoYXJ0LWJhc2UvY2hhcnQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGFzaGJvYXJkQ29tcG9uZW50IH0gZnJvbSAnLi4vZGFzaGJvYXJkL2Rhc2hib2FyZC5jb21wb25lbnQnO1xuZXhwb3J0IGludGVyZmFjZSBGb3JtYXR0ZXIge1xuICAgIGZvcm1hdHRlcjogZ29vZ2xlLnZpc3VhbGl6YXRpb24uRGVmYXVsdEZvcm1hdHRlcjtcbiAgICBjb2xJbmRleDogbnVtYmVyO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgR29vZ2xlQ2hhcnRDb21wb25lbnQgaW1wbGVtZW50cyBDaGFydEJhc2UsIE9uQ2hhbmdlcywgT25Jbml0IHtcbiAgICBwcml2YXRlIGVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBzY3JpcHRMb2FkZXJTZXJ2aWNlO1xuICAgIHByaXZhdGUgZGFzaGJvYXJkPztcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgY2hhcnQgdG8gY3JlYXRlLlxuICAgICAqL1xuICAgIHR5cGU6IENoYXJ0VHlwZTtcbiAgICAvKipcbiAgICAgKiBEYXRhIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgdGFibGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG11c3QgYWxzbyBjb250YWluIGFsbCByb2xlcyB0aGF0IGFyZSBzZXQgaW4gdGhlIGBjb2x1bW5zYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBkYXRhOiBSb3dbXTtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1ucyB0aGUgYGRhdGFgIGNvbnNpc3RzIG9mLlxuICAgICAqIFRoZSBsZW5ndGggb2YgdGhpcyBhcnJheSBtdXN0IG1hdGNoIHRoZSBsZW5ndGggb2YgZWFjaCByb3cgaW4gdGhlIGBkYXRhYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBJZiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2hhcnQvaW50ZXJhY3RpdmUvZG9jcy9yb2xlcyByb2xlc30gc2hvdWxkIGJlIGFwcGxpZWQsIHRoZXkgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGlzIGFycmF5IGFzIHdlbGwuXG4gICAgICovXG4gICAgY29sdW1uczogQ29sdW1uW107XG4gICAgLyoqXG4gICAgICogQSBjb252ZW5pZW5jZSBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgdGl0bGUgb2YgdGhlIGNoYXJ0LlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gYWxzbyBiZSBzZXQgdXNpbmcgYG9wdGlvbnMudGl0bGVgLCB3aGljaCwgaWYgZXhpc3RhbnQsIHdpbGwgb3ZlcndyaXRlIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgdGl0bGU/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQSBjb252ZW5pZW5jZSBwcm9wZXJ0eSB1c2VkIHRvIHNldCB0aGUgd2lkdGggb2YgdGhlIGNoYXJ0IGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGFsc28gYmUgc2V0IHVzaW5nIGBvcHRpb25zLndpZHRoYCwgd2hpY2gsIGlmIGV4aXN0YW50LCB3aWxsIG92ZXJ3cml0ZSB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIHdpZHRoPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEEgY29udmVuaWVuY2UgcHJvcGVydHkgdXNlZCB0byBzZXQgdGhlIGhlaWdodCBvZiB0aGUgY2hhcnQgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gYWxzbyBiZSBzZXQgdXNpbmcgYG9wdGlvbnMuaGVpZ2h0YCwgd2hpY2gsIGlmIGV4aXN0YW50LCB3aWxsIG92ZXJ3cml0ZSB0aGlzIHZhbHVlLlxuICAgICAqL1xuICAgIGhlaWdodD86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hhcnQtc3BlY2lmaWMgb3B0aW9ucy4gQWxsIG9wdGlvbnMgbGlzdGVuIGluIHRoZSBHb29nbGUgQ2hhcnRzIGRvY3VtZW50YXRpb24gYXBwbHlpbmdcbiAgICAgKiB0byB0aGUgY2hhcnQgdHlwZSBzcGVjaWZpZWQgY2FuIGJlIHVzZWQgaGVyZS5cbiAgICAgKi9cbiAgICBvcHRpb25zOiBvYmplY3Q7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjaGFuZ2UgdGhlIGRpc3BsYXllZCB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGNvbHVtbiBpbiBhbGwgcm93cy5cbiAgICAgKlxuICAgICAqIEVhY2ggYXJyYXkgZWxlbWVudCBtdXN0IGNvbnNpc3Qgb2YgYW4gaW5zdGFuY2Ugb2YgYSBbYGZvcm1hdHRlcmBdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2NoYXJ0L2ludGVyYWN0aXZlL2RvY3MvcmVmZXJlbmNlI2Zvcm1hdHRlcnMpXG4gICAgICogYW5kIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHlvdSB3YW50IHRoZSBmb3JtYXR0ZXIgdG8gZ2V0IGFwcGxpZWQgdG8uXG4gICAgICovXG4gICAgZm9ybWF0dGVycz86IEZvcm1hdHRlcltdO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgc2V0IHRvIGB0cnVlYCwgdGhlIGNoYXJ0IHdpbGwgYmUgcmVkcmF3biBpZiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgcmVzaXplZC5cbiAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgIGFuZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gc3BlY2lmeWluZyB0aGUgd2lkdGggb3IgaGVpZ2h0IG9mIHRoZSBjaGFydFxuICAgICAqIGluIHBlcmNlbnQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBjYW4gaW1wYWN0IHBlcmZvcm1hbmNlLlxuICAgICAqL1xuICAgIGR5bmFtaWNSZXNpemU6IGJvb2xlYW47XG4gICAgcmVhZHk6IEV2ZW50RW1pdHRlcjxDaGFydFJlYWR5RXZlbnQ8Z29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRCYXNlPj47XG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxDaGFydEVycm9yRXZlbnQ+O1xuICAgIHNlbGVjdDogRXZlbnRFbWl0dGVyPENoYXJ0U2VsZWN0aW9uQ2hhbmdlZEV2ZW50PjtcbiAgICBtb3VzZW92ZXI6IEV2ZW50RW1pdHRlcjxDaGFydE1vdXNlT3ZlckV2ZW50PjtcbiAgICBtb3VzZWxlYXZlOiBFdmVudEVtaXR0ZXI8Q2hhcnRNb3VzZUxlYXZlRXZlbnQ+O1xuICAgIHByaXZhdGUgZGF0YVRhYmxlO1xuICAgIHByaXZhdGUgcmVzaXplU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgd3JhcHBlcjtcbiAgICBwcml2YXRlIHdyYXBwZXJSZWFkeVN1YmplY3Q7XG4gICAgcHJpdmF0ZSBpbml0aWFsaXplZDtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50UmVmLCBzY3JpcHRMb2FkZXJTZXJ2aWNlOiBTY3JpcHRMb2FkZXJTZXJ2aWNlLCBkYXNoYm9hcmQ/OiBEYXNoYm9hcmRDb21wb25lbnQpO1xuICAgIHJlYWRvbmx5IGNoYXJ0OiBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydEJhc2UgfCBudWxsO1xuICAgIHJlYWRvbmx5IHdyYXBwZXJSZWFkeSQ6IGltcG9ydChcInJ4anNcIikuT2JzZXJ2YWJsZTxnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydFdyYXBwZXI+O1xuICAgIGNoYXJ0V3JhcHBlcjogZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyO1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgcHJpdmF0ZSBjcmVhdGVEYXRhVGFibGU7XG4gICAgcHJpdmF0ZSBnZXREYXRhQXNUYWJsZTtcbiAgICBwcml2YXRlIHVwZGF0ZVJlc2l6ZUxpc3RlbmVyO1xuICAgIHByaXZhdGUgbWVyZ2VPcHRpb25zO1xuICAgIHByaXZhdGUgYXBwbHlGb3JtYXR0ZXJzO1xuICAgIHByaXZhdGUgcmVnaXN0ZXJDaGFydEV2ZW50cztcbiAgICBwcml2YXRlIGRyYXdDaGFydDtcbn1cbiJdfQ==